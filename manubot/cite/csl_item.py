import re
import logging

from manubot.cite.citekey import standardize_citekey, infer_citekey_prefix, is_valid_citekey
from manubot.cite.citeproc import remove_jsonschema_errors, get_jsonschema_csl_validator


csl_item_type_fixer = {
    'journal-article': 'article-journal',
    'book-chapter': 'chapter',
    'posted-content': 'manuscript',
    'proceedings-article': 'paper-conference',
    'standard': 'entry',
    'reference-entry': 'entry',
}

class CSL_Item(dict):
    """
    CSL_Item represents bibliographic information for a single publication.

    On a technical side CSL_Item is a Python dictionary with extra methods
    that help cleaning and manipulating it.

    These methods relate to:
    - adding an `id` key and value for CSL item
    - correcting bibliographic information   
    - adding and reading a custom note to CSL item

    """
    # The ideas for CSL_Item methods come from the following parts of code:
    #  - citekey_to_csl_item(citekey, prune=True)
    #  - csl_item_passthrough
    #  - append_to_csl_item_note
    # The methods provide primitives to reconstruct these fucntions.

    def __init__(self, incoming_dict: dict = {}):        
        super().__init__(incoming_dict)

    # def csl_item_passthrough(csl_item, set_id=None, prune=True):
    #     """
    #     Fix errors in a CSL item, according to the CSL JSON schema, and optionally
    #     change its id.

    #     http://docs.citationstyles.org/en/1.0.1/specification.html
    #     http://citeproc-js.readthedocs.io/en/latest/csl-json/markup.html
    #     https://github.com/citation-style-language/schema/blob/master/csl-data.json
    #     """
    #     if set_id is not None:
    #         csl_item['id'] = set_id
    #     logging.debug(f"Starting csl_item_passthrough with{'' if prune else 'out'} CSL pruning for id: {csl_item.get('id', 'id not specified')}")

    def set_id(self, x):
        self['id'] = x
        return self

    #     # Correct invalid CSL item types
    #     # See https://github.com/CrossRef/rest-api-doc/issues/187
    #     if 'type' in csl_item:
    #         csl_item['type'] = csl_item_type_fixer.get(csl_item['type'], csl_item['type'])
    
    def fix_type(self):
        # Correct invalid CSL item types
        # See https://github.com/CrossRef/rest-api-doc/issues/187
        try:
            self['type'] = csl_item_type_fixer[self['type']]
        except KeyError:
            pass
        return self

    # prune parameter is likely to be supported by two methods:
    
    def remove_jsonschema_errors(self):
        csl_item, = remove_jsonschema_errors([self])
        return CSL_Item(csl_item)   

    def validate_csl_schema(self):
        validator = get_jsonschema_csl_validator()
        validator.validate([self])

    # These methods can be used in code below:
    #
    #     if prune:
    #         # Remove fields that violate the CSL Item JSON Schema
    #         csl_item, = remove_jsonschema_errors([csl_item])

    #     # Default CSL type to entry
    #     csl_item['type'] = csl_item.get('type', 'entry')

    #     if prune:
    #         # Confirm that corrected CSL validates
    #         validator = get_jsonschema_csl_validator()
    #         validator.validate([csl_item])
    #     return csl_item

    # -----------------------------------------------------------------------------------
    #
    # append_to_csl_item_note() can be implemented using two methods below.

    def append_note_text(self, text: str):
        note = str(self.get('note', ''))
        if note and not note.endswith('\n'):
            note += '\n'
        note += text
        self['note'] = note
    
    def append_note_dict(self, dictionary: dict):
        def log(key, reason: str):
            msg = (f'append_to_csl_item_note: skipped adding "{key}",'
                     '\nreason: {reason}')
            logging.warning(msg)            
        dict_items = []                            
        for key, value in dictionary.items():
            if not re.fullmatch(r'[A-Z]+|[-_a-z]+', key):
                log(key, 'value "{value}" does not conform to the variable_name ' 
                         'syntax as per https://git.io/fjTzW.')                
                continue
            if '\n' in value:
                log(key, 'value "{value}" contains a newline')
                continue
            dict_items.append(f'{key}: {value}')
        self.append_note_text('\n'.join(dict_items))    

    #     note_text = f'This CSL JSON Item was automatically generated by Manubot v{manubot_version} using citation-by-identifier.'
    #     note_dict = {
    #         'standard_id': citekey,
    #     }
    #     append_to_csl_item_note(csl_item, note_text, note_dict)

    def add_note_manubot_version(self, version=None):
        if version is None:
            from manubot import __version__ as manubot_version
            version = manubot_version
        self.append_note_text('This CSL JSON Item was automatically generated '
                              f'by Manubot v{version} using citation-by-identifier.')
        return self

    def add_note_standard_id(self, citekey:str):
        self.append_note_dict({'standard_id': citekey})
        return self

    # def append_to_csl_item_note(csl_item, text='', dictionary={}):
    #     """
    #     Add information to the note field of a CSL Item.
    #     In addition to accepting arbitrary text, the note field can be used to encode
    #     additional values not defined by the CSL JSON schema, as per
    #     https://github.com/Juris-M/citeproc-js-docs/blob/93d7991d42b4a96b74b7281f38e168e365847e40/csl-json/markup.rst#cheater-syntax-for-odd-fields
    #     Use dictionary to specify variable-value pairs.
    #     """
    #     if not isinstance(csl_item, dict):
    #         raise ValueError(f'append_to_csl_item_note: csl_item must be a dict but was of type {type(csl_item)}')
    #     if not isinstance(dictionary, dict):
    #         raise ValueError(f'append_to_csl_item_note: dictionary must be a dict but was of type {type(dictionary)}')
    #     if not isinstance(text, str):
    #         raise ValueError(f'append_to_csl_item_note: text must be a str but was of type {type(text)}')
    #     note = str(csl_item.get('note', ''))
    #     if text:
    #         if note and not note.endswith('\n'):
    #             note += '\n'
    #         note += text
    #     for key, value in dictionary.items():
    #         if not re.fullmatch(r'[A-Z]+|[-_a-z]+', key):
    #             logging.warning(f'append_to_csl_item_note: skipping adding "{key}" because it does not conform to the variable_name syntax as per https://git.io/fjTzW.')
    #             continue
    #         if '\n' in value:
    #             logging.warning(f'append_to_csl_item_note: skipping adding "{key}" because the value contains a newline: "{value}"')
    #             continue
    #         if note and not note.endswith('\n'):
    #             note += '\n'
    #         note += f'{key}: {value}'
    #     if note:
    #         csl_item['note'] = note
    #     return csl_item

    def note_dict(self):
        return parse_csl_item_note(self['note'])

    def minimal(self):
        """Return csl item with a minimal set of keys."""
        keys = ('title author URL issued type container-title'
                'volume issue page DOI').split()
        return CSL_Item({k: v for k, v in self.items() if k in keys})


def parse_csl_item_note(note: str):
    """
    Return the dictionary of key-value pairs encoded in a CSL JSON note.
    Extracts both forms (line-entry and braced-entry) of key-value pairs from "cheater syntax"
    https://github.com/Juris-M/citeproc-js-docs/blob/93d7991d42b4a96b74b7281f38e168e365847e40/csl-json/markup.rst#cheater-syntax-for-odd-fields
    """
    note = str(note) # type safeguard 
    line_matches = re.findall(
        r'^(?P<key>[A-Z]+|[-_a-z]+): *(?P<value>.+?) *$', note, re.MULTILINE)
    braced_matches = re.findall(
        r'{:(?P<key>[A-Z]+|[-_a-z]+): *(?P<value>.+?) *}', note)
    return dict(line_matches + braced_matches)


# csl_item_set_standard_id(csl_item: CSL_Item) ->  CSL_Item
def csl_item_set_standard_id(csl_item):
    """
    Extract the standard_id (standard citation key) for a csl_item and modify the csl_item in-place to set its "id" field.
    The standard_id is extracted from a "standard_citation" field, the "note" field, or the "id" field.
    If extracting the citation from the "id" field, uses the infer_citekey_prefix function to set the prefix.
    For example, if the extracted standard_id does not begin with a supported prefix (e.g. "doi:", "pmid:"
    or "raw:"), the citation is assumed to be raw and given a "raw:" prefix. The extracted citation
    (referred to as "original_standard_id") is checked for validity and standardized, after which it is
    the final "standard_id".

    Regarding csl_item modification, the csl_item "id" field is set to the standard_citation and the note field
    is created or updated with key-value pairs for standard_id, original_standard_id, and original_id.

    Note that the Manubot software generally refers to the "id" of a CSL Item as a citekey.
    However, in this context, we use "id" rather than "citekey" for consistency with CSL's "id" field.
    """
    if not isinstance(csl_item, dict):
        raise ValueError(
            "csl_item must be a CSL Data Item represented as a Python dictionary")

    from manubot.cite.citeproc import (
        append_to_csl_item_note,
        parse_csl_item_note,
    )
    note_dict = parse_csl_item_note(csl_item.get('note', ''))

    original_id = None
    original_standard_id = None
    if 'id' in csl_item:
        original_id = csl_item['id']
        original_standard_id = infer_citekey_prefix(original_id)
    if 'standard_id' in note_dict:
        original_standard_id = note_dict['standard_id']
    if 'standard_citation' in csl_item:
        original_standard_id = csl_item.pop('standard_citation')
    if original_standard_id is None:
        raise ValueError(
            'csl_item_set_standard_id could not detect a field with a citation / standard_citation. '
            'Consider setting the CSL Item "id" field.')
    assert is_valid_citekey(original_standard_id, allow_raw=True)
    standard_id = standardize_citekey(
        original_standard_id, warn_if_changed=False)
    # FIXME: can be changed to below after omitting 'warn_if_changed' parameter in 
    #        favour of individual logger funciton
    # standard_id = standardize_citekey(original_standard_id)       
    add_to_note = {}
    if original_id and original_id != standard_id:
        if original_id != note_dict.get('original_id'):
            add_to_note['original_id'] = original_id
    if original_standard_id and original_standard_id != standard_id:
        if original_standard_id != note_dict.get('original_standard_id'):
            add_to_note['original_standard_id'] = original_standard_id
    if standard_id != note_dict.get('standard_id'):
        add_to_note['standard_id'] = standard_id
    append_to_csl_item_note(csl_item, dictionary=add_to_note)
    csl_item['id'] = standard_id
    return csl_item
